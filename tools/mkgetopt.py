#! /usr/bin/env python3

# mkgetopt.py - a simple generator of typesafe, 'C' command line option
#               parsing code using getopt_long(3). 
#
# Documentation in mkgetopt-manual.txt
#
# (c) 2005-2009 Sudhi Herle <sw at herle.net>
#
# Author: Sudhi Herle <sw at herle.net>
# License: GPLv2 Only
#
# Note: The code generated by the tool is NOT under the GPL. It uses
#       whatever license/copyright the user of the tool wishes.

import os, sys, random, os.path
import re, textwrap
from optparse import OptionParser
from io import open

Z = os.path.basename(sys.argv[0])
__version__ = '1.0.2'

__doc__ = """
%s [options] input-file

%s is a python script to generate type-safe getopt_long() option parsing
routines.

Version: %s
Author: Sudhi Herle <sudhi@herle.net>
License: GPLv2

""" % (Z, Z, __version__)

class bundle:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

class opt_output(object):
    """Simple class to capture output of the type-specific  generator"""
    def __init__(self, **kwargs):
        self.init      = "\n"
        self.init_p    = "\n"
        self.casestmt  = '\n' + ' ' * 12 + "break;\n\n"
        self.typestr   = "\n"
        self.typestr_p = "\n"

        self.__dict__.update(kwargs)

class opt_type(object):
    """Base class for opt_TYPE objects. Defines common methods and
    stuff"""

    optional_arg_template = ' ' * 12 + """else
            {
                opt->%(varname_p)s = 1;
                ++opt->%(varname)s;
            }
"""

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def is_int(self):
        return False

    def is_size(self):
        return False

    def is_string(self):
        return False

    def generate(self, opt, outstate):
        return opt_output()


class opt_int(opt_type):

    template = """
            if (optarg && *optarg)
            {
                opt->%(varname)s = (%(ctype)s)grok_int(optarg, "%(optname)s",
                                    &opt->%(varname_p)s, &errs,
                                    %(limit)s, 1);
            }
"""

    def __init__(self, **kwargs):
        opt_type.__init__(self, **kwargs)

    def is_int(self):
        return True

    def generic_int(self, opt, limit):
        optname = opt.long_opt
        if not optname:
            optname = opt.short_opt

        defstr = opt.default
        if defstr.startswith('0x'):
            base = 16
        elif defstr.startswith('0'):
            base = 8
        else:
            base = 10

        try:
            if defstr:
                defval = int(defstr, base)
            else:
                defval = 0
        except:
            raise Invalid_Default("Invalid characters in integer '%s'" % defstr)

        d = {
            'varname': opt.varname,
            'varname_p': opt.varname_p,
            'ctype':    self.ctype,
            'limit':    limit,
            'optname':  optname,
            'default':  defval,
        }

        str = self.template % d
        if opt.optarg:
            str += self.optional_arg_template % d

        str += " " * 12 + "break;\n\n"
        ret_str    = str % d

        type_str   = ' ' * 4 + "%(ctype)s %(varname)s;\n" % d
        type_str_p = ' ' * 4 + "char %(varname_p)s;\n" % d
        init_str   = ' ' * 4 + "opt->%(varname)s = %(default)d;\n" % d
        init_str_p = ' ' * 4 + "opt->%(varname_p)s = 0;\n" % d

        return opt_output(init=init_str, init_p=init_str_p,
                          casestmt=ret_str, typestr=type_str,
                          typestr_p=type_str_p)


    def generate(self, opt, outstate):
        max = "INT_MAX"
        if self.ctype.endswith('short'):
            max = "SHRT_MAX"
        elif self.ctype.endswith('int'):
            max = "INT_MAX"
        elif self.ctype.endswith('long long'):
            max = "LLONG_MAX"
        elif self.ctype.endswith('long'):
            max = "LONG_MAX"

        if self.ctype.startswith('unsigned'):
            max = 'U' + max

        return self.generic_int(opt, max)

class opt_size(opt_type):
    template = """
            if (optarg && *optarg)
                opt->%(varname)s = grok_size(optarg, "%(optname)s",
                                    &opt->%(varname_p)s, &errs);
"""

    def __init__(self, **kwargs):
        opt_type.__init__(self, **kwargs)

    def is_size(self):
        return True

    def generate(self, opt, outstate):
        optname = opt.long_opt
        if not optname:
            optname = opt.short_opt

        defval = groksize(opt.default)

        d = {
            'varname': opt.varname,
            'varname_p': opt.varname_p,
            'ctype':    self.ctype,
            'optname':  optname,
            'default':  defval,
        }

        str = self.template % d
        if opt.optarg:
            str += self.optional_arg_template % d

        str += " " * 12 + "break;\n\n"
        ret_str    = str % d

        type_str   = ' ' * 4 + "%(ctype)s %(varname)s;\n" % d
        type_str_p = ' ' * 4 + "char %(varname_p)s;\n" % d
        init_str   = ' ' * 4 + "opt->%(varname)s = %(default)d;\n" % d
        init_str_p = ' ' * 4 + "opt->%(varname_p)s = 0;\n" % d

        return opt_output(init=init_str, init_p=init_str_p,
                          casestmt=ret_str, typestr=type_str,
                          typestr_p=type_str_p)


class opt_callback(opt_type):
    template = """
            opt->%(varname_p)s = 1;
            assert(opt->%(varname)s);
            if (optarg && *optarg)
                (*opt->%(varname)s)(opt, optarg);
            else
                (*opt->%(varname)s)(opt, 0);
            break;

"""

    def __init__(self, **kwargs):
        #print "Created obj of type 'callback'"
        opt_type.__init__(self, **kwargs)

    def generate(self, opt, outstate):
        d = {
            'varname': opt.varname,
            'varname_p': opt.varname_p,
            'ctype':    self.ctype,
            'structname': outstate.structname,
        }

        str = self.template % d

        pres_str  = "    opt->%(varname_p)s = 0;\n" % d
        typestr_p = "    char %(varname_p)s;\n" % d
        type_str  = "    "
        type_str += self.ctype % d
        type_str += ";\n"
        return opt_output(init="", init_p=pres_str,
                          casestmt=str, typestr=type_str, typestr_p=typestr_p)

class opt_bool(opt_type):

    def __init__(self, **kwargs):
        opt_type.__init__(self, **kwargs)

    def generate(self, opt, outstate):
        #return ("", "")
        def_str_val = "0";
        defval  = opt.default.lower()
        if defval == "true" or defval == "yes":
           def_str_val = "1";

        d = {
            'varname': opt.varname,
            'varname_p': opt.varname_p,
            'ctype':    self.ctype,
            'default': def_str_val,
        }

        str = """
            opt->%(varname)s = 1;
            opt->%(varname_p)s = 1;\n""" % d

        if opt.builtin:
            if opt.long_opt == 'help':
                str += " " * 12 + "fflush(stdout);\n"
                str += " " * 12 + "fflush(stderr);\n"
                str += " " * 12 + "show_help();\n"
            elif opt.long_opt == 'version':
                str += " " * 12 + "fflush(stdout);\n"
                str += " " * 12 + "fflush(stderr);\n"
                str += " " * 12 + "show_version();\n"

        str += " " * 12 + "break;\n\n"

        def_str    = "    opt->%(varname)s = %(default)s;\n" % d
        pres_str   = "    opt->%(varname_p)s = 0;\n" % d

        type_str   = "    %(ctype)s %(varname)s;\n" % d
        type_str_p = "    char %(varname_p)s;\n" % d

        return opt_output(init=def_str, init_p=pres_str,
                          casestmt=str, typestr=type_str, typestr_p=type_str_p)



class opt_float(opt_type):
    template = """
            if (optarg && *optarg)
            {
                char* xxptr  = 0;
                double xxdbl = strtod(optarg, &xxptr);

                if (xxptr)
                {
                    if (xxptr == optarg)
                    {
                        ++errs;
                        error(0, 0, "Invalid characters '%%s' for floating point value in option '%(optname)s'", xxptr);
                    }
                    else if (*xxptr)
                        error(0, 0, "Ignoring trailing characters '%%s' for option '%(optname)s'", xxptr);
                    else
                    {
                        opt->%(varname)s = xxdbl;
                        opt->%(varname_p)s = 1;
                    }
                }
            }
            break;\n\n"""

    def __init__(self, **kwargs):
        opt_type.__init__(self, **kwargs)

    def generate(self, opt, outstate):
        optname = opt.long_opt
        if not optname:
            optname = opt.short_opt

        try:
            dblval = float(opt.default)
        except:
            raise Invalid_Default("Invalid chars in floating point value '%s'" % opt.default)

        d = {
            'varname':   opt.varname,
            'varname_p': opt.varname_p,
            'ctype':     self.ctype,
            'optname':   optname,
            'default':   opt.default,
        }

        case_str   = self.template % d
        type_str   = ' ' * 4 + "%(ctype)s %(varname)s;\n" % d
        type_str_p = ' ' * 4 + "char %(varname_p)s;\n" % d
        init_str   = ' ' * 4 + "opt->%(varname)s = %(default)s;\n" % d
        init_str_p = ' ' * 4 + "opt->%(varname_p)s = 0;\n" % d

        return opt_output(init=init_str, init_p=init_str_p,
                          casestmt=case_str, typestr=type_str,
                          typestr_p=type_str_p)


# Same type with different name
opt_double = opt_float

class opt_string(opt_type):
    template = """
            opt->%(varname_p)s = 1;
            if (optarg && *optarg)
                opt->%(varname)s = dupstr(optarg);
            break;\n\n"""

    def __init__(self, **kwargs):
        opt_type.__init__(self, **kwargs)

    def is_string(self):
        return True

    def generate(self, opt, outstate):
        optname = opt.long_opt
        if not optname:
            optname = opt.short_opt

        d = {
            'varname': opt.varname,
            'varname_p': opt.varname_p,
            'ctype':    self.ctype,
            'optname':  optname,
            'default':   opt.default,
        }

        case_str = self.template % d
        type_str   = ' ' * 4 + "%(ctype)s %(varname)s;\n" % d
        type_str_p = ' ' * 4 + "char %(varname_p)s;\n" % d
        init_str   = ' ' * 4 + """opt->%(varname)s = dupstr("%(default)s");\n""" % d
        init_str_p = ' ' * 4 + "opt->%(varname_p)s = 0;\n" % d

        return opt_output(init=init_str, init_p=init_str_p,
                          casestmt=case_str, typestr=type_str,
                          typestr_p=type_str_p)

def typeinfo(**kwargs):
    """Return an instance of opt_TYPE class"""
    typ = kwargs['type']
    nm  = 'opt_' + typ
    try:
        cls = eval(nm)
    except:
        raise Exception("Can't find type generator class '%s()'" % nm)

    return cls(**kwargs)


Types = {
    'ushort':   typeinfo(needsarg=True, type='int', ctype='unsigned short'),
    'uint':     typeinfo(needsarg=True, type='int', ctype='unsigned int'),
    'ulong':    typeinfo(needsarg=True, type='int', ctype='unsigned long'),
    'short':    typeinfo(needsarg=True, type='int', ctype='short'),
    'int':      typeinfo(needsarg=True, type='int', ctype='int'),
    'long':     typeinfo(needsarg=True, type='int', ctype='long'),
    'size':     typeinfo(needsarg=True, type='size', ctype='uint64_t'),
    'float':    typeinfo(needsarg=True, type='float', ctype='double'),
    'double':   typeinfo(needsarg=True, type='float', ctype='double'),
    'string':   typeinfo(needsarg=True, type='string', ctype='char*'),
    'bool':     typeinfo(needsarg=False, type='bool', ctype='int'),
    'flag':     typeinfo(needsarg=False, type='bool', ctype='int'),
    'boolean':  typeinfo(needsarg=False, type='bool', ctype='int'),

    'callback': typeinfo(needsarg=False, type='callback',
                         ctype='void (*%(varname)s)(%(structname)s *, char* arg)'),
    'callback_arg': typeinfo(needsarg=True, type='callback',
                         ctype='void (*%(varname)s)(%(structname)s *, char* arg)'),
 }



# Useful constants
_kB = 1024
_MB = _kB * 1024
_GB = _MB * 1024
_TB = _GB * 1024
_PB = _TB * 1024
_Multipliers = {
    'k': _kB,
    'K': _kB,
    'M': _MB,
    'G': _GB,
    'T': _TB,
    'P': _PB,
}

def groksize(str):
    """Convert a string containing integers with an optional suffix
    of 'k', 'M', 'G', 'T', 'P' - denoting kilo, Mega, Giga, Tera and
    Peta bytes.
    """

    x    = str[-1]
    mult = 1
    if x.isalpha():
        str  = str[:-1]
        mult = _Multipliers.get(x, 0)
        if mult == 0:
            raise Invalid_Default("Suffix '%s' not understood in size '%s'" % (x, str))

    if str.startswith('0x'):
        base = 16
    elif str.startswith('0'):
        base = 8
    else:
        base = 10
    try:
        v = int(str, base)
    except:
        raise Invalid_Default("Invalid characters in size '%s'" % str)

    return mult * v


def error(doex, fmt, *args):
    global Z
    sfmt = "%s: %s" % (Z, fmt)
    if args:
        sfmt = sfmt % args

    if not sfmt.endswith("\n"):
        sfmt += "\n"

    sys.stderr.write(sfmt)
    if doex:
        sys.exit(doex)


# List of exceptions thrown by the parser
class Parse_Error(Exception):
    def __init__(self, str):
        self.what = str
        Exception.__init__(self, str)

    def __repr__(self):
        return self.what

    __str__ = __repr__

class Invalid_Directive(Exception):
    def __init__(self, str):
        self.what = str
        Exception.__init__(self, str)

    def __repr__(self):
        return self.what

    __str__ = __repr__

class Invalid_Option(Exception):
    def __init__(self, str):
        self.what = str
        Exception.__init__(self, str)

    def __repr__(self):
        return self.what

    __str__ = __repr__


class Invalid_Default(Exception):
    def __init__(self, str):
        self.what = str
        Exception.__init__(self, str)

    def __repr__(self):
        return self.what

    __str__ = __repr__


class option:
    """A representation of a command line option"""

    # Globally incremented option count
    optcount = 0

    def __init__(self, args, fn, ln, builtin=False):
        global Types

        nargs = len(args)
        #print args
        if nargs < 4:
            raise Invalid_Option("Too few parameters to option")

        self.line      = ln
        self.filename  = fn
        self.long_opt  = args[0]
        self.short_opt = args[1]
        self.varname   = args[2]
        self.type      = args[3]

        self.placeholder = False
        if nargs < 6:
            if self.type == 'callback':
                self.help = args[4]
                self.default = ""
            else:
                # Variable place holder
                self.placeholder = True
                self.help = ""
                if nargs > 4:
                    self.default = args[4]
                else:
                    self.default = ""

        else:
            self.placeholder = False
            self.default   = args[4]
            self.help      = args[5]



        self.builtin   = builtin
        self.varname_p = self.varname + '_present'
        self.hasarg    = False
        self.optarg    = False
        self.is_int    = False
        self.is_size   = False
        self.is_string = False

        self.optnum    = option.optcount + 300
        option.optcount += 1

        # Validation
        if self.placeholder:
            self.long_opt  = None
            self.short_opt = None
        else:
            if self.long_opt == '-' and self.short_opt == '-':
                raise Invalid_Option("Both short and long options are empty")

            optname = None
            if self.long_opt == '-':
                self.long_opt = None
            else:
                optname = self.long_opt

            if self.short_opt == '-':
                self.short_opt = None
            elif not optname:
                optname = self.short_opt

        if self.varname == '-':
            raise Invalid_Option("Option '%s' has no variable name" % optname)

        if self.type.endswith('?'):
            self.type = self.type[:-1]
            optarg    = True
        else:
            optarg    = False

        ty = Types.get(self.type, None)
        if ty is None:
            raise Invalid_Option("Option '%s' has invalid type %s" % (optname, self.type))

        if not self.placeholder:
            if ty.is_int():
                self.is_int = True
            elif ty.is_size():
                self.is_size = True
            elif ty.is_string():
                self.is_string = True

        if ty.needsarg:
            self.optarg = optarg
            self.hasarg = True
        else:
            self.optarg = False
            self.hasarg = False
            if optarg:
                error(0, "%s:%d: Ignoring OPTIONAL-ARG modifier to type %s",
                        self.filename, self.line, self.type)

    def __str__(self):
        s = "%d.%s: %s|%s (%s)" % (self.optnum, self.varname, self.long_opt, \
                                self.short_opt, self.type)
        return s

    def __repr__(self):
        return self.__str__()


    def make_short_opt(self, opstate):
        if self.short_opt is None:
            self.shortopt_str = ""
            return

        s = self.short_opt
        if self.hasarg:
            s += ":"
        if self.optarg:
            s += ":"

        #print "SHORT: |%s|" % s
        self.shortopt_str = s

    def make_long_opt(self, opstate):
        if self.long_opt is None:
            self.longopt_str = ""
            return

        s = '    , {"' + self.long_opt + '",'
        s += ' ' * (32 - len(self.long_opt))
        if self.hasarg:
            if self.optarg:
                s += "optional_argument,"
            else:
                s += "required_argument,"
        else:
            s += "no_argument,      "

        s += " 0, "
        s += "%d" % self.optnum
        s += "}\n"

        #print "LONG: |%s|" % s
        self.longopt_str = s


    def make_help_line(self, max_help_len):

        if self.placeholder:
            self.help_str = ""
            return

        s = ' ' * 4
        arg = ""
        if self.long_opt:
            fc  = self.long_opt[0]
            arg = self.short_opt
            if arg is None:
                arg = fc

            s += "--%s" % self.long_opt
            if self.hasarg:
                s += "=%s" % arg.lower()

        if self.short_opt:
            s += ", -%s" % self.short_opt
            if self.hasarg:
                s += " %s" % arg.lower()

        l = len(s)
        s += ' ' * (max_help_len - l)

        tw = textwrap.TextWrapper(width=74, #initial_indent=' ' * (max_help_len-1),
                                     subsequent_indent=' ' * (max_help_len-1))

        helps = self.help
        if self.default != '-' and self.type != 'callback':
            helps += " [%s]" % self.default

        w = list(map(lambda x: x + '\\n"\n', tw.wrap(helps)))
        l = w[:1]
        for x in w[1:]:
            x = '" ' + x
            l.append(x)
        hs = ''.join(l)

        self.help_str = '"%s%s' % (s, hs)


    def make_stmt(self, opstate):
        global Types

        tm = Types[self.type]
        self.output = tm.generate(self, opstate)

        if self.placeholder:
            self.output.casestmt = ""
            return

        s = ' ' * 8
        msg = self.long_opt
        if msg is None:
            msg = self.short_opt

        s += "case %d:  /* %s */" % (self.optnum, msg)
        if self.short_opt:
            s += '\n' + (' ' * 8) + "case '%s':  /* %s */" % (self.short_opt, msg)


        #print "Generating stmt for %s" % self.type
        self.output.casestmt = s + self.output.casestmt


    def generate(self, opstate):
        """Generate code for this option"""

        self.make_short_opt(opstate)
        self.make_long_opt(opstate)
        self.make_help_line(opstate.max_help_len)
        self.make_stmt(opstate)


class output_state:
    """Class to hold the output state of the program. This is the
    central class controlling generation of output.

    When new options are parsed from the input file, they are added via
    the 'add_option()' method.

    If any directives that affect internal state are recognized, then
    the appropriate method is called - del_help() and del_version().
    """

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
        self.sym_prefix     = "opt"
        self.typename       = self.sym_prefix + "_option"
        self.structname     = 'struct %s' % self.typename
        self.nopermute      = False
        self.noversion      = False
        self.nohelp         = False
        self.description    = []
        self.description_fp = None
        self.needs_size     = False
        self.needs_int      = False
        self.needs_string   = False
        self.options        = []
        self.shortmap       = {}
        self.longmap        = {}
        self.varmap         = {}
        self.max_help_len   = 0

        h = option(['help', 'h', 'help', 'bool', 'false',
                     "Print this help and exit"], "<builtin>", 0, True)
        v = option(['version', 'V', 'version', 'bool', 'false',
                     "Print version information and exit"], "<builtin>", 0, True)

        # Always add the builtin options unless told otherwise.
        self.add_option(h)
        self.add_option(v)

    def add_option(self, opt):
        """Add an option to our option_state. The option is an instance
           of the option class and has already been validated.
           We only need to ensure there are no duplicates.
        """
        if opt.long_opt and opt.long_opt in self.longmap:
            other = self.longmap[opt.long_opt]
            raise Invalid_Option("Duplicate option %s (last seen at line %d)" \
                    % (opt.long_opt, other.line))

        if opt.short_opt:
            if opt.short_opt in self.shortmap:
                other = self.shortmap[opt.short_opt]
                raise Invalid_Option("Duplicate option %s (last seen at line %d)" \
                        % (opt.short_opt, other.line))

        if opt.varname in self.varmap:
            other = self.varmap[opt.varname]
            raise Invalid_Option("Duplicate variable name %s (last seen at line %d)" \
                    % (opt.varname, other.line))

        n = 10
        if opt.long_opt:
            n += len(opt.long_opt)
        if opt.hasarg:
            n += 5

        if opt.short_opt:
            n += len(opt.short_opt)

        if n > self.max_help_len:
            self.max_help_len = n
    
        # Don't add to linear list if it is builtin
        if not opt.builtin:
            self.options.append(opt)

        if opt.is_int:
            self.needs_int  = True
        elif opt.is_size:
            self.needs_size = True
        elif opt.is_string:
            self.needs_string = True

        self.varmap[opt.varname] = opt
        if opt.long_opt:
            self.longmap[opt.long_opt] = opt
        if opt.short_opt:
            self.shortmap[opt.short_opt] = opt
        

    def del_help(self):
        """Remove the --help option.
        This is called when the directive '%nohelp' is recognized.
        """
        self.nohelp = True
        del self.longmap['help']
        del self.shortmap['h']

    def del_version(self):
        """Remove the --version option.
        This is called when the directive '%nohelp' is recognized.
        """
        self.noversion = True
        del self.longmap['version']
        del self.shortmap['V']


    def format_help(self):
        """Fix up 'helpstr' with description and/or usage_call data"""

        if self.description_fp:
            self.usage      = self.description_fp + '()'
            self.usage_decl = """
/**
 * User supplied external callback for providing program usage.
 * This function must return a string that can be printed on console.
 */
extern const char* %s(void);\n\n""" % self.description_fp

        else:
            self.usage     = '""'
            self.usage_decl = ""

        brief = self.description[0]
        if not brief.endswith('.'):
            brief += '.'

        desc = ' '.join(self.description[1:])
        tw   = textwrap.TextWrapper(width=74)
        w    = map(lambda x: '"' + x + '\\n"\n', tw.wrap(desc))
        self.description = '"' + brief + '\\n\\n"\n' + ''.join(w)


    def generate(self, onames):
        """
        Generate all output.
        """

        global H_template, C_template
        global __version__, Z
        global Grok_int_template, Grok_int_decl
        global Grok_size_template, Grok_size_decl
        global Help_template, Version_template
        global Dupstr_template

        template = C_template
        decls    = ""


        if self.needs_int:
            decls += "static unsigned long grok_int(const char * str, const char * option, char * present, int * err, unsigned long limit, int has_limit);\n"
            template += Grok_int_template

        if self.needs_size:
            decls += "static uint64_t grok_size(const char * str, const char * option, char * present, int * err);\n"
            template += Grok_size_template


        if self.needs_string:
            decls += "static char* dupstr(const char*);\n"
            template += Dupstr_template

        # add the builtin options to list of data that must be
        # processed.
        if not self.noversion:
            self.options.insert(0, self.longmap['version'])
            decls += "static void show_version(void);\n"
            template += Version_template

        if not self.nohelp:
            self.options.insert(0, self.longmap['help'])
            decls += "static void show_help(void);\n"
            template += Help_template



        defaults = ""
        casestmt = ""
        longopt  = ""
        shortopt = ""
        helpstr  = """"\\nOptions (defaults within '[ ]'):\\n"\n"""
        typestmt = ""
        typestmt_p = ""
        pres     = ""
        for x in self.options:
            #print x
            x.generate(self)
            o = x.output

            typestmt += o.typestr
            defaults += o.init
            if not x.placeholder:
                helpstr  += x.help_str
                shortopt += x.shortopt_str
                longopt  += x.longopt_str
                casestmt += o.casestmt
                typestmt_p += o.typestr_p
                pres     += o.init_p




        # Erase leading ',' of long-options. This is the first option
        i = longopt.find(',')
        longopt = longopt[:i] + ' ' + longopt[i+1:]

        # If no permute is given, tell getopt_long() by prefixing with
        # '+'
        if self.nopermute:
            shortopt = '+' + shortopt

        # Fixup help string with program description and such.
        self.format_help()

        prefix   = onames.prefix or self.sym_prefix
        typename = "%s_option" % prefix

        d = {
            'typestr':   typestmt,
            'typestr_p': typestmt_p,
            'init':      defaults + "\n" + pres,
            'longopt':   longopt,
            'shortopt':  shortopt,
            'cfile':     onames.cfile,
            'hfile':     onames.hfile,
            'guard':     onames.guard,
            'infile':    onames.infile,
            'casestmt':  casestmt,
            'decls':     decls,
            'version':       __version__,
            'prog':          sys.argv[0],


            'options':     helpstr,
            'description': self.description,
            'usage':       self.usage,
            'usage_decl':  self.usage_decl,

            'prefix':      prefix,
            'structname': 'struct %s' % typename,
            'typename':    typename,
        }
        

        fd = open(onames.hfile, 'w')
        fd.write(H_template % d)
        fd.close()

        fd = open(onames.cfile, 'w')
        fd.write(template % d)
        fd.close()

        

        
class line_parser:
    """Parser to parse each line of the input configuration file.

    State machine driven. Each state has a corresponding function.
    """

    START   = 0
    INWORD  = 1
    INQUOTE = 2
    INSPACE = 3
    FIN     = 4


    def __init__(self, line, op):
        self.line  = line.strip()
        self.op    = op

        # Bound methods
        self.state_machine = {
            self.START:   self.do_start,
            self.INWORD:  self.do_word,
            self.INQUOTE: self.do_quote,
            self.INSPACE: self.do_space,
            self.FIN:     self.do_fin,
        }

        self.directives = {
            'description': self.dir_description,
            'usage_call':  self.dir_usage_call,
            'prefix':      self.dir_prefix,
            'nopermute':   self.dir_nopermute,
            'noversion':   self.dir_noversion,
            'nohelp':      self.dir_nohelp,
        }


    def parse_directive(self, d, args):
        fp = self.directives.get(d, None)
        if fp is None:
            raise Invalid_Directive("Directive '%s' is unknown" % d)

        fp(args)

    def dir_prefix(self, args):
        self.op.sym_prefix = args

    def dir_nopermute(self, args):
        self.op.nopermute = True

    def dir_noversion(self, args):
        self.op.del_version()

    def dir_nohelp(self, args):
        self.op.del_help()

    def dir_description(self, args):
        w = self.parse_internal(args)
        self.op.description.append(w[0])

    def dir_usage_call(self, args):
        self.op.description_fp = args

    def parse(self):
        return self.parse_internal(self.line)

    def parse_internal(self, line):

        # Initialize state for parser
        self.state     = self.START
        self.words     = []
        self.word      = ""
        self.quotechar = None

        if line.startswith('#'):
            return []

        if line.startswith('%'):
            v = line[1:].split()
            d = v[0]
            v = v[1:]
            self.parse_directive(d, ' '.join(v))
            return []

        if len(line) == 0:
            return []

        for c in line:
            if c == '\n':
                break

            fp = self.state_machine[self.state]
            st = fp(c)
            #print "%d -> %s" % (self.state, st)

            self.state = st
            if self.state == self.FIN:
                break

        # cleanup any pending words
        if self.state == self.INWORD:
            self.words.append(self.word)
            self.word = ""
        return self.words

    def do_start(self, c):
        if c.isspace():
            return self.INSPACE

        elif c == '"' or c == '"':
            self.quotechar = c
            return self.INQUOTE
        else:
            self.word += c
            return self.INWORD

    def do_space(self, c):
        if c.isspace():
            return self.INSPACE

        elif c == '"' or c == "'":
            self.quotechar = c
            return self.INQUOTE
        else:
            self.word += c
            return self.INWORD

    def do_word(self, c):
        if c.isspace():
            self.words.append(self.word)
            self.word = ""
            return self.INSPACE

        elif c == '"' or c == "'":
            raise Parse_Error("Invalid quote in middle of word '%s'" % self.word)
        else:
            self.word += c
            return self.INWORD

    def do_quote(self, c):
        if c == self.quotechar:
            self.words.append(self.word)
            self.word = ""
            return self.START

        else:
            self.word += c
            return self.INQUOTE

    def do_fin(self, c):
        raise Parse_Error("Should not get into FIN state on '%s'" % c)



class parser:
    """Command line options file parser driver"""

    def __init__(self, filename, outstate):
        self.op = outstate
        self.fn = filename

    def parse(self):
        if self.fn == '-':
            self.fn = '<stdin>'
            fd      = sys.stdin
        else:
            fd = open(self.fn, 'r')

        ln = 0
        for line in fd:
            ln += 1
            try:
                p   = line_parser(line, self.op)
            except Exception as x:
                error(1, "%s:%d: %s", self.fn, ln, x.what)

            try:
                w   = p.parse()
            except Parse_Error as x:
                error(0, "%s:%d: %s", self.fn, ln, x.what)
                continue
            except Invalid_Directive as x:
                error(0, "%s:%d: %s", self.fn, ln, x.what)
                continue

            if len(w) > 0:
                try:
                    opt = option(w, self.fn, ln)
                    self.op.add_option(opt)
                except Invalid_Option as x:
                    error(0, "%s:%d: %s", self.fn, ln, x.what)
                    continue

        if self.fn != '-':
            fd.close()


def make_output_names(infile, opt):
    """Given an input file and command line options, generate all the
    various file names that will be created. Additionally, setup the
    symbol prefix.

    This function returns an object with attributes for various
    filenames and symbol prefixes.
    """

    # Derive a file prefix
    i = infile.rfind('.')
    if i < 0:
        pref = infile[:]
    else:
        pref = infile[:i]

    # Command line overrides derived names
    cfile = opt.cfile or pref + '.c'
    hfile = opt.hfile or pref + '.h'

    # Create header guard for '#ifdef __foo__'
    guard = hfile.upper()
    rex   = re.compile(r'[^A-Za-z0-9_]')
    guard = '___' + rex.sub('_', guard) + "_%d" % random.randint(100000, 999999999) + '___'

    return bundle(cfile=cfile, hfile=hfile, infile=infile,
                  guard=guard, prefix=opt.prefix)


def main(argc, argv):
    global Z


    cmd = OptionParser(__doc__)

    cmd.add_option("-P", "--prefix", dest="prefix", action="store",
                   type="string", default=None, metavar="S",
                   help="Override generated symbol prefix with 'D'")

    cmd.add_option("-H", "--header-output", dest="hfile", action="store",
                   type="string", default=None, metavar="F",
                   help="Write generated header to file 'F'")

    cmd.add_option("-C", "--c-file-output", dest="cfile", action="store",
                   type="string", default=None, metavar="F",
                   help="Write generated C source to file 'F'")

    (opt, args) = cmd.parse_args(args=argv[1:])

    if len(args) < 1:
        error(1, "Usage: %s [options] input-file", Z)

    infile  = args[0]
    o_names = make_output_names(infile, opt)


    os = output_state()
    p  = parser(infile, os)
    p.parse()

    os.generate(o_names)




# --- Templates ---


H_template = """/*
 * Automatically generated by %(prog)s [v%(version)s]
 * Input file: %(infile)s
 *
 * DO NOT EDIT THIS FILE!
 *
 * Make all changes in %(infile)s.
 */
#ifndef %(guard)s
#define %(guard)s 1

/* ANSI/ISO headerfile that defines exact width types */
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/** Struct containing parsed options.
 *
 * There are two kinds of elements here:
 *    a) members with a one-to-one mapping to option specification in
 *       the input file. These will be set to parsed command line
 *       values.
 *
 *    b) Boolean flags whose names match the member names above but,
 *       with the added suffix of "_present". These are set to true iff a
 *       command line option was used. These boolean flags can be used
 *       to know when something has a "default" value vs. something set
 *       by command line parsing.
 *
 *  Lastly, the two members 'argv_inputs' and 'argv_count' hold the
 *  remaining arguments and count respectively.
 */
struct %(typename)s
{
    /* Points to remaining/unconsumed command line arguments.
     * These are unconsumed either because:
     *   1. The argument parsing was explicitly stopped by use of
     *      the "--" command line option.
     *   2. There are no more options (starting with "-" or "--")
     */
    char * const * argv_inputs;

    /*
     * Contains a count of remaining command line arguments in
     * 'argv_inputs' above.
     */
    int     argv_count;

%(typestr)s

    /*
     * Boolean flags to denote if any of above vars were recognized
     * during command line processing
     */
%(typestr_p)s
};
typedef struct %(typename)s %(typename)s;



/** Command line parser function
 *
 *  @input argv Array of command line options (obtained via main())
 *              argv[0] is assumed to contain the invoking program
 *              name and will be skipped.
 *  @input argc Count of number of items in the 'argv' array above.
 *
 *  @output opt Pointer to an instance of the option struct defined
 *              above. Upon successful parsing of the command line
 *              options, the appropriate member variables of this
 *              struct will be hold the option values and associated
 *              arguments.
 *
 *  @return 0   if successful
 *         >0   if options were unrecognized or arguments were
 *              incorrect or missing
 */
extern int %(prefix)s_parse(%(typename)s * opt, int argc, char * const *argv);


/** Callback function to obtain the version information
 *
 *  The user of this library must supply an implementation of this
 *  function. The generated 'main_opt_parse()' will call this function to
 *  display program version information - when the command line
 *  option "--version" is recognized.
 *
 *  @return string This constant string must contain the version
 *                 number of the invoking program.
 */
extern const char * %(prefix)s_version(void);

%(usage_decl)s

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* %(guard)s */

/* EOF */
"""

C_template = """/*
 * Automatically generated by %(prog)s [v%(version)s]
 * Input file: %(infile)s
 *
 * DO NOT EDIT THIS FILE!
 *
 * Make all changes in %(infile)s.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <assert.h>
#include <errno.h>


#include "getopt_long.h"
#include "error.h"

#include "%(hfile)s"

static const struct option Long_options[] =
{
%(longopt)s
    , {0, 0, 0, 0}
};

static const char Short_options[] = "%(shortopt)s";

%(decls)s


/*
 * Parse command line options.
 * Return:
 *    0 on success
 *    > 0 on error (number of errors encountered)
 */
int
%(prefix)s_parse(%(typename)s * opt, int argc, char * const *argv)
{
    int c,
        errs = 0;

    /*
     * Assume that getopt library has been used before this call;
     * and reset explicitly.
     */
    optind = 0;

%(init)s

    opt->argv_inputs = 0;
    opt->argv_count  = 0;

    if (argc == 0)
        return 0;

    if (argc < 0 || !argv || !argv[0])
        return 0;

    while ((c = getopt_long(argc, argv, Short_options, Long_options, 0)) != EOF) {
        switch (c) {
%(casestmt)s

        default:
            ++errs;
            break;
        }
    }

    opt->argv_inputs = &argv[optind];
    opt->argv_count  = argc - optind;

    /*
     * Reset getopt library for next use.
     */
    optind = 0;

    return errs;
}

"""

Dupstr_template = """
/*
 * Duplicate a string. Many systems don't have strdup().
 */
static char*
dupstr(const char* s)
{
    size_t n = 1 + strlen(s);
    char  *x = (char *)calloc(1, n);
    if (x) memcpy(x, s, n);

    return x;
}
"""

Help_template = """
static void
show_help(void)
{
    const char* desc =
%(description)s;
    const char* usage = %(usage)s;
    const char* options = 
%(options)s;

    fflush(stdout);
    fflush(stderr);
    printf("%%s: %%s", program_name, desc);
    fputs(usage, stdout);
    fputs(options, stdout);
    fflush(stdout);
    fflush(stderr);
    exit(0);
}
"""


Version_template = """
static void
show_version(void)
{
    const char * ver = %(prefix)s_version ();

    fflush(stdout);
    fflush(stderr);
    printf("%%s -- %%s\\n", program_name, ver);
    fflush(stdout);
    fflush(stderr);
    exit(0);
}
"""



Grok_int_template = """
/**
 * @memo Grok a integer in any base (auto detect)
 *
 * @param str     String containing an integer (possibly signed)
 * @param option  The corresponding option string (for emitting errors)
 * @param present Output value -- true if there are no errors, false otherwise
 * @param err     Output value -- incremented on errors
 * @param limit   The maximum permissible limit for this integer
 * @param has_limit   Set if the corresponding option had a size limitation
 *                (e.g., a short integer etc.)
 * @return Converted string value.
 */
static unsigned long
grok_int(const char * str, const char * option, char * present, int * err,
            unsigned long limit, int has_limit)
{
    char * xxend = 0;
    long lim_pos = (long) limit,
         lim_neg = -lim_pos - 1;
    int isneg = 0;
    union
    {
        long l;
        unsigned long ul;
    } un;

    if (*str == '-') {
        ++str;
        isneg = 1;
    }

    un.ul = strtoul(str, &xxend, 0);
    if (xxend && *xxend)
        error(0, 0, "Ignoring trailing characters '%%s' for option '%%s'", xxend, option);

    if (isneg) {
        un.l *= -1;
    }

    if (has_limit) {
        if (isneg && un.l < lim_neg) {
            *err += 1;
            error(0, 0, "Integer value '-%%s' underflow for option '%%s' (min %%ld)",
                    str, option, lim_neg);
        } else if (!isneg && un.ul > (unsigned long)lim_pos) {
            *err += 1;
            error(0, 0, "Integer value '%%s' overflow for option '%%s' (max %%lu)",
                    str, option, lim_pos);
        }
    }
    else
        *present = 1;

    return un.ul;
}
"""


Grok_size_template = """
/**
 * @memo Grok a size specification string.
 *
 * @doc Handles suffixes of 'k', 'M', 'G', 'T', 'P'
 *
 * @param str     String containing size like '36k' or '14M'
 * @param option  The corresponding option string (for emitting errors)
 * @param present Output value -- true if there are no errors, false otherwise
 * @param err     Output value -- incremented on errors
 *
 * @return Converted value of the size
 */
static uint64_t
grok_size(const char * str, const char * option, char * present, int * err)
{
    int errs = 0;
    uint64_t   xxbase = 0,
               xxmult = 1,
               xxval  = 0;

    char * xxend = 0;

    /* MS is weird. They deliberately chose NOT to use names that the rest
     * of the world uses. */
#ifdef _MSC_VER
#define strtoull(a,b,c,)  _strtoui64(a,b,c)
#define _ULLCONST(n) n##ui64
#else
#define _ULLCONST(n) n##ULL
#endif

#define UL_MAX__    _ULLCONST(18446744073709551615)
#define _kB         _ULLCONST(1024)
#define _MB         (_kB * 1024)
#define _GB         (_MB * 1024)
#define _TB         (_GB * 1024)
#define _PB         (_TB * 1024)

    *present = 1;
    xxbase = strtoull(str, &xxend, 0);

    if (xxend && *xxend) {
        switch (*xxend) {
            case 'b': case 'B':
                break;
            case 'k': case 'K':
                xxmult = _kB;
                break;
            case 'M':
                xxmult = _MB;
                break;
            case 'G':
                xxmult = _GB;
                break;
            case 'T':
                xxmult = _TB;
                break;
            case 'P':
                xxmult = _PB;
                break;
            default:
                errs++;
                error(0, 0, "Unknown multilplier constant '%%c'  for option '%%s'",
                        *xxend, option);
                *present = 0;
                break;
        }

        xxval = xxbase * xxmult;
        if ((xxbase == UL_MAX__ && errno == ERANGE) || (xxval < xxbase)) {
            errs++;
            error(0, 0, "Size value overflow for option '%%s' (base %%lu, multiplier %%lu)",
                    option, xxbase, xxmult);
            *present = 0;
        }
    } else
        xxval = xxbase;

    *err += errs;
    return xxval;
}

"""


# Invoke main
main(len(sys.argv), sys.argv)

# vim: expandtab:sw=4:ts=4:tw=72:notextmode:
